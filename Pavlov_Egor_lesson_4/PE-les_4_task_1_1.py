# Задание 1 Вариант 1
# Проанализировать скорость и сложность одного любого алгоритма
# из разработанных в рамках домашнего задания первых трех уроков.

# для начала взял 3-е задание 2-го урока можно применить и строковые методы и числовые
# # Сформировать из введенного числа обратное по порядку входящих в него цифр и вывести на экран.
# # Например, если введено число 3486, надо вывести 6843.

import cProfile
import random
import timeit


def from_the_end_v1(data, spam=''):
    if data == 0:
        return int(spam)
    else:
        return from_the_end_v1(int(data) // 10, spam + str(data % 10))


def from_the_end_v2(data):
    data = str(data)[::-1]
    return int(data)  # преобразование к int увеличивает время на 1/3


def from_the_end_v3(data):
    data, spam = str(data), ''
    for i in range(len(data)):
        spam += data[len(data) - i - 1]
    return int(spam)


n = random.randint((100_000_000**10), (1_000_000_000**10))
atmpts = 1000  # кол-во замеров
rounding = 10  # округление результатов замеров

print('Дано значение n:', '\n', n, sep='')
print('-' * 45)

print('Функция с "Рекурсия" - from_the_end_v1')
print('Функция с "Строковый метод" - from_the_end_v2')
print('Функция с "Цикл"- from_the_end_v3')
print(f'Функции возвращают одинаковые значения: {from_the_end_v1(n) == from_the_end_v2(n) == from_the_end_v3(n)}')
print(f'Попыток на каждый случай: {atmpts}')
print('-' * 45)

# задание сделал сразу после урока, но очень не нравился хард код с замерами (по 5 строчек на 1 фукнцию).
# Поэтому переспал с этим и написал табличный вывод

max_column = 5

matrix = [['Название функции']]
for i in range(1, 4):
    matrix.append([])
    matrix[i].append(f'from_the_end_v{i}')
    for j in range(2, max_column + 2):
        n, spam = n ** j, n
        el = round(timeit.timeit(f'from_the_end_v{i}({n})', number=atmpts, globals=globals()), rounding)
        matrix[i].append(el)
        if len(matrix[0]) <= max_column:
            matrix[0].append(f'n**{j}')
        n = spam
for el in matrix:
    for i in el:
        print(f'|{i:^16}|', end=' ')
    print('\n', '-' * (max_column * 22))

"""
Дано значение n:
668952653145600029999935453408894075382073901270764208391752353380485165447550898251044910
---------------------------------------------
Функция с "Рекурсия" - from_the_end_v1
Функция с "Строковый метод" - from_the_end_v2
Функция с "Цикл"- from_the_end_v3
Функции возвращают одинаковые значения: True
Попыток на каждый случай: 1000
---------------------------------------------
|Название функции| |      n**2      | |      n**3      | |      n**4      | |      n**5      | |      n**6      | 
 --------------------------------------------------------------------------------------------------------------
|from_the_end_v1 | |    0.087974    | |   0.1567259    | |   0.2389653    | |   0.3136271    | |   0.4311628    | 
 --------------------------------------------------------------------------------------------------------------
|from_the_end_v2 | |   0.0018718    | |   0.0030993    | |    0.004612    | |    0.006657    | |    0.009078    | 
 --------------------------------------------------------------------------------------------------------------
|from_the_end_v3 | |   0.0250702    | |    0.037158    | |   0.0721108    | |   0.1012541    | |   0.0978081    | 
 --------------------------------------------------------------------------------------------------------------

2й вариант функции со строковым методом оказался на порядок быстрее остальных.
На самом деле это откровение для меня:).
Вариант с рекурсией даже дольше откровенно мудренного 3-го варианта.
"""

cProfile.run('from_the_end_v1(n**6)')
cProfile.run('from_the_end_v2(n**6)')
cProfile.run('from_the_end_v3(n**6)')

"""
тут все более менее понятно, способы не сложные, проблем не должно быть, кроме ограничений связанных с рекурсиями.
в третьем варианте 537 вызывается функция len но мы уже знаем что это не проблема, т.к. данные записаны в заголовке.
"""
